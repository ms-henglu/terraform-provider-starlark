---
page_title: "eval function - terraform-provider-starlark"
subcategory: ""
description: |-
  Executes a Starlark script with provided inputs.
---

# function: eval

The `eval` function allows you to execute Starlark (a dialect of Python) scripts within your Terraform configuration. This is particularly useful for complex logic that is difficult or impossible to express with standard Terraform functions, such as custom data transformations, date calculations, or implementing Bicep-like functions that are missing in Terraform.

## Quickstart Examples

Check out the [Quickstart Examples](https://github.com/ms-henglu/terraform-provider-starlark/tree/main/quickstart) in the repository for runnable code:

*   [Basic Math](https://github.com/ms-henglu/terraform-provider-starlark/tree/main/quickstart/01-basic-math)
*   [String Processing](https://github.com/ms-henglu/terraform-provider-starlark/tree/main/quickstart/02-string-processing)
*   [Complex Logic](https://github.com/ms-henglu/terraform-provider-starlark/tree/main/quickstart/03-complex-logic)
*   [External Script](https://github.com/ms-henglu/terraform-provider-starlark/tree/main/quickstart/04-external-script)
*   [Date To Epoch](https://github.com/ms-henglu/terraform-provider-starlark/tree/main/quickstart/05-datetime-to-epoch) (Bicep `dateTimeToEpoch`)
*   [Epoch To Date](https://github.com/ms-henglu/terraform-provider-starlark/tree/main/quickstart/06-datetime-from-epoch) (Bicep `dateTimeFromEpoch`)
*   [Parse CIDR](https://github.com/ms-henglu/terraform-provider-starlark/tree/main/quickstart/07-parse-cidr) (Bicep `parseCidr`)

## Example Usage

### Basic Usage

```terraform
output "calculation" {
  value = provider::starlark::eval(
    <<-EOT
    result = a + b
    EOT
    ,
    {
      a = 10
      b = 20
    }
  )
}
# Output: 30
```

### Complex Logic (Using Definitions)

```terraform
output "parsed_list" {
  value = provider::starlark::eval(
    <<-EOT
    def get_list():
      return [1, 2, 3]
    
    result = get_list()
    EOT
    ,
    {}
  )
}
# Output: [1, 2, 3]
```

### Reusable Scripts

For complex or frequently used scripts, it is a best practice to define the script content in a `locals` block. This keeps your configuration clean and allows you to reuse the logic across multiple resources.

```terraform
locals {
  # Define the script once
  greet_script = <<-EOT
    def greet(n):
      return "Hello, " + n + "!"

    result = greet(name)
  EOT
}

output "greeting_1" {
  value = provider::starlark::eval(local.greet_script, { name = "Alice" })
}
# Output: "Hello, Alice!"

output "greeting_2" {
  value = provider::starlark::eval(local.greet_script, { name = "Bob" })
}
# Output: "Hello, Bob!"
```

### Implementing Bicep Workarounds

See the [Quickstart Examples](https://github.com/ms-henglu/terraform-provider-starlark/tree/main/quickstart) for ready-to-use implementations of Bicep functions like `dateTimeToEpoch`, `dateTimeFromEpoch`, and `parseCidr`.

## Signature

<!-- signature generated by tfplugindocs -->
```text
eval(script string, inputs dynamic) dynamic
```

## Arguments

1. `script` (String) The Starlark source code to execute. The script should assign the final return value to a global variable named `result`.
2. `inputs` (Dynamic) A map of values to inject into the Starlark global scope. These can be accessed directly by name within the script.

## Return Value

(Dynamic) The value of the global variable `result` defined in the Starlark script. This can be a string, number, boolean, list, or map/object.

## Best Practices & Limitations

*   **Reusable Logic**: Define scripts in `locals` blocks to improve readability and reusability, especially for non-trivial logic.
*   **Result Variable**: Always assign your return value to a global variable named `result`.
*   **Loops**: This provider enables `while` loops and recursion, allowing for more complex control flow than standard Starlark dialects which often disable them.
*   **Deterministic Execution**: Starlark is designed to be deterministic. Avoid operations that rely on external state or randomness if not explicitly supported.
*   **Inputs**: Pass Terraform variables via the `inputs` map rather than interpolating them directly into the script string. This avoids syntax errors and injection issues.

